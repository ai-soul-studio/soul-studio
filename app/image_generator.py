import os
from io import BytesIO
from PIL import Image
import time
from google import genai
from google.genai import types # Ensure types is imported
from . import config
import logging
from tenacity import retry, wait_exponential, stop_after_attempt, retry_if_exception_type
from datetime import datetime

logger = logging.getLogger(__name__)

def _apply_art_style_to_prompt(prompt: str, art_style: str = None) -> str:
    """Appends art style to the prompt if provided and not 'none'."""
    if art_style and art_style.lower() != 'none' and art_style.lower() != config.DEFAULT_ART_STYLE.lower(): # Avoid duplicate "cinematic" if it's default
        return f"{prompt.strip()}, style: {art_style}"
    elif art_style and art_style.lower() == config.DEFAULT_ART_STYLE.lower() and not "cinematic" in prompt.lower() : # Add default if not there
        return f"{prompt.strip()}, style: {config.DEFAULT_ART_STYLE}"
    return prompt.strip()


@retry(
    wait=wait_exponential(multiplier=1, min=config.API_RETRY_DELAY_MIN, max=config.API_RETRY_DELAY_MAX),
    stop=stop_after_attempt(config.API_RETRY_ATTEMPTS),
    retry=retry_if_exception_type(Exception),
    reraise=True
)
def generate_image_from_prompt(visual_prompt: str, output_dir: str, base_filename: str, art_style: str = None, aspect_ratio: str = "1:1") -> str | None:
    """
    Generates an image from a given visual prompt. Helper function.
    """
    os.makedirs(output_dir, exist_ok=True)
    
    final_prompt = _apply_art_style_to_prompt(visual_prompt, art_style)
    logger.info(f"Generating image with final prompt: {final_prompt[:150]}...")

    try:
        client = genai.Client(api_key=os.environ.get("GEMINI_API_KEY"))
        
        # Using client.generate_content for Imagen model as per latest practices if applicable
        # Or client.models.generate_images if that's the specific method for your genai version for Imagen
        # Assuming client.models.generate_images is correct as per your original code
        response = client.models.generate_images( # Corrected based on your original
            model=config.GEMINI_IMAGE_MODEL,
            prompt=final_prompt,
            config=types.GenerateImagesConfig( # Corrected
                number_of_images=1,
                output_mime_type="image/jpeg", # Changed to output_mime_type from your original
                person_generation="ALLOW_ADULT", # Keep ALLOW_ADULT as per original if needed
                aspect_ratio=aspect_ratio,
            )
        )
        
        if not response.generated_images: # Check against the attribute name from your original code
            logger.warning("No images generated by API.")
            return None
            
        # Save the generated image (assuming only one image is requested and generated)
        image_filename = f"{base_filename}.jpg"
        image_path = os.path.join(output_dir, image_filename)
        
        generated_image_data = response.generated_images[0] # Accessing the first image
        
        # The structure might be generated_image_data.image_bytes directly or nested
        # Adapting to a common structure for genai library image generation results
        image_bytes_to_save = None
        if hasattr(generated_image_data, 'image') and hasattr(generated_image_data.image, 'image_bytes'):
             image_bytes_to_save = generated_image_data.image.image_bytes # As per your original
        elif hasattr(generated_image_data, 'image_bytes'): # Simpler structure
             image_bytes_to_save = generated_image_data.image_bytes

        if image_bytes_to_save:
            image = Image.open(BytesIO(image_bytes_to_save))
            image.save(image_path, "JPEG")
            logger.info(f"Image saved to: {image_path}")
            return image_path
        else:
            logger.warning("Generated image data does not contain image_bytes.")
            return None
            
    except Exception as e:
        logger.error(f"Error generating image with prompt '{final_prompt[:50]}...': {e}")
        raise
    return None


def generate_image_from_script(script_content: str, output_dir: str = None, art_style: str = None, run_id: str = None) -> str | None:
    """
    Generate a single image based on overall script content.
    Uses run_id for consistent file naming if provided.
    """
    if output_dir is None:
        output_dir = config.OUTPUT_IMAGE_DIR
    
    visual_prompt = extract_visual_prompt_from_script(script_content)
    if not visual_prompt:
        logger.warning("Could not extract a visual prompt from script content for general image.")
        return None

    file_identifier = run_id if run_id else f"overview_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
    base_filename = f"{file_identifier}_overview" # Changed from script_overview_ to use run_id
    return generate_image_from_prompt(visual_prompt, output_dir, base_filename, art_style, "1:1")


def extract_visual_prompt_from_script(script_content: str) -> str | None:
    """
    Fallback: Extract a general visual description from script content.
    This is now primarily a fallback or for a general "cover" image.
    """
    lines = script_content.split('\n')
    descriptive_lines = []
    for line in lines:
        line = line.strip()
        if not line or line.startswith('Style:') or line.startswith('VISUAL_PROMPT:'): # Ignore visual prompt lines too
            continue
        if ':' in line: # Remove speaker
            parts = line.split(':', 1)
            if len(parts) == 2 and len(parts[0].split()) <= 3: line = parts[1].strip()
        
        if line: descriptive_lines.append(line)
    
    if not descriptive_lines: return None
    
    visual_content = ' '.join(descriptive_lines[:5]) # Take a bit more for general context
    return f"Cinematic overview: {visual_content[:250]}"


def generate_thumbnail_for_script(script_path: str, output_dir: str = None, art_style: str = None, run_id: str = None) -> str | None: # Added run_id
    try:
        with open(script_path, 'r', encoding='utf-8') as f:
            script_content = f.read()
        # Use the general image function for thumbnail, passing run_id
        return generate_image_from_script(script_content, output_dir, art_style, run_id=run_id)
    except Exception as e:
        logger.error(f"Error generating thumbnail for script {script_path}: {e}")
        return None

def generate_scene_images_from_segments(
    script_segments_with_visuals: list[dict],
    output_dir: str = None,
    art_style: str = None,
    run_id: str = None # Added run_id
) -> list[dict]:
    """
    Generate images for each script segment that has a visual prompt.
    Uses run_id for consistent file naming if provided.
    
    Args:
        script_segments_with_visuals (list[dict]): List of segment dicts, where each dict
            is expected to have 'scene_number' (or index), 'text', and 'visual_prompt'.
            It will also be updated with 'image_path'.
        output_dir (str): Directory to save the generated images.
        art_style (str): Overall art style to apply to images.
        
    Returns:
        list[dict]: The input list, with 'image_path' (str or None) added to each segment.
    """
    if output_dir is None:
        output_dir = config.OUTPUT_IMAGE_DIR
    os.makedirs(output_dir, exist_ok=True)
    
    updated_segments = []

    for idx, segment_info in enumerate(script_segments_with_visuals):
        scene_number = segment_info.get('scene_number', segment_info.get('index', idx + 1))
        visual_prompt = segment_info.get('visual_prompt')
        text_for_fallback = segment_info.get('text', '')
        
        current_image_path = None

        if not visual_prompt or visual_prompt.lower() == "no specific visual prompt for this segment.":
            logger.info(f"No detailed visual prompt for scene {scene_number}. Attempting fallback using text.")
            visual_prompt = extract_visual_prompt_from_script(text_for_fallback) # Fallback
            if not visual_prompt:
                logger.warning(f"Fallback prompt extraction also failed for scene {scene_number}. Skipping image generation.")
                segment_info['image_path'] = None
                updated_segments.append(segment_info)
                continue
        
        # Use run_id and scene_number for a more consistent and traceable filename
        # Timestamp still useful for potential re-runs on the same scene if needed, or can be omitted if run_id is unique enough
        # For now, keeping a timestamp for uniqueness during development/testing.
        # If run_id is guaranteed unique per generation, timestamp here might be redundant.
        # Let's simplify to run_id + scene_number for cleaner grouping.
        # If run_id is None, fall back to a timestamped scene name.
        if run_id:
            base_filename = f"{run_id}_scene_{scene_number}"
        else:
            # Fallback if run_id is not available (e.g., direct testing of this function)
            base_filename = f"scene_{scene_number}_{datetime.now().strftime('%Y%m%d_%H%M%S%f')}"

        try:
            current_image_path = generate_image_from_prompt(
                visual_prompt,
                output_dir, 
                base_filename, 
                art_style, 
                aspect_ratio="16:9" # Widescreen for scenes
            )
            if current_image_path:
                 logger.info(f"Scene {scene_number} image generated: {current_image_path}")
            else:
                 logger.warning(f"Image generation returned None for scene {scene_number} with prompt: {visual_prompt[:50]}...")
            
            time.sleep(config.API_RETRY_DELAY_MIN) # Respect rate limits
        except Exception as e:
            logger.error(f"Error generating image for scene {scene_number}: {e}")
        
        segment_info['image_path'] = current_image_path
        updated_segments.append(segment_info)
        
    return updated_segments